<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="github.com/whx4J8">
<meta property="og:type" content="website">
<meta property="og:title" content="学而后知不足">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="学而后知不足">
<meta property="og:description" content="github.com/whx4J8">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学而后知不足">
<meta name="twitter:description" content="github.com/whx4J8">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> 学而后知不足 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">学而后知不足</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/21/高并发下接口的并发问题/" itemprop="url">
                  高并发下接口的并发问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-21T21:23:44+08:00" content="2016-07-21">
              2016-07-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/线上bug解决/" itemprop="url" rel="index">
                    <span itemprop="name">线上bug解决</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="事故"><a href="#事故" class="headerlink" title="事故"></a>事故</h4><p>前些天上线的扫码送会员活动。<br>场景：用户登录账号之后，扫二维码，送七天黄金会员，限制每个帐号只能领取一个<br>      有恶意用户刷接口，在高并发下越过限制。</p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><pre><code>领取会员流程：
    1.后端先生成卡卷，将卡号放到消息队列中
    2.用户扫码请求领取会员接口
        2-1).先检查用户是否已经领取过该活动会员
        2-2).领取过return “该帐号已领取”的标示  
        2-3).没领取从消息队列中拿取一张卡号
        2-4).激活卡
        2-5).更新用户本次活动为已经激活
</code></pre><p>这个流程在一般环境下是没有问题的，在高并发下就不行了。</p>
<pre><code>            2-1)        2-2)         2-3)       2-4)      2-5)

线程a                                                   --&gt;

线程b                                      --&gt;

线程c                                    --&gt;
</code></pre><p>高并发下模拟几个线程同时请求</p>
<p>现在的rpc服务，除去极其敏感性数据的操作，其它数据的接口基本都没有做数据一致性控制。</p>
<p>其实做了控制也不能解决这个问题。再来说这个问题，高并发下因为线程a已经执行完激活卡的操作，用户的会员已经建立权益。但这时候线程a还没有执行到2-5，还没更新用户的领取卡卷的状态，这时候，又有一个这个用户的领取卡卷请求过来。2-1的check 操作并不能阻止这个请求，同样的再次领取卡卷并且激活，导致线程a在的执行在2-1到2-5之间都会有其它的线程越过检查。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>解决这种并发问题无非是两种，悲观锁和乐观锁。<br>悲观锁阻塞，乐观锁快速响应失败。</p>
<pre><code>                优点                        缺点

悲观锁        可以响应重复请求，幂等            高并发下请求堆积


乐观锁        高并发下没有大量线程阻塞        不可重复响应，不幂等
</code></pre><p>考虑并发量比较大，采用的乐观锁实现。对流程进行加锁。</p>
<p>2种实现方式：redis和mysql，考虑下在不修改原表的情况下，使用redis的SETNX的api</p>
<p>实现：</p>
<pre><code>    2-0).活动-帐号形成key，SETNX(key)成功返回1，失败返回0
          只有返回1，才能进行后续流程，将并发控制交给redis，redis是线程模型没有并发问题
    2-1).先检查用户是否已经领取过该活动会员
    2-2).领取过return “该帐号已领取”的标示  
    2-3).没领取从消息队列中拿取一张卡号
    2-4).激活卡
    2-5).更新用户本次活动为已经激活
    2-6).将删除活动-帐号形成的key


        2-0)    2-1)   2-2)     2-3)  2-4)  2-5)   2-6)

线程a   -&gt;1                                          

线程b   -&gt;0                                   
         &lt;-    
线程c     -&gt;0                            
         &lt;-

只有线程a已经执行过2-6，才能线程b进入流程，但是这时候用户已经为领取过卡卷状态            
线程a                                                    -&gt;

线程b  -&gt;1 用户卡卷已经更新过

线程c  -&gt;0                                            
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/19/浏览器302重定向之迷/" itemprop="url">
                  浏览器302重定向之迷
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-19T23:39:29+08:00" content="2016-07-19">
              2016-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/线上bug解决/" itemprop="url" rel="index">
                    <span itemprop="name">线上bug解决</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="事故"><a href="#事故" class="headerlink" title="事故"></a>事故</h4><p>晚上9点左右忽然爆出线上支付宝wap拉不起来。<br>场景：h5页面点击确认支付，不能拉起支付，<br>      但是直接拿到确认支付的请求，放在浏览器中可以拉起支付。</p>
<h4 id="排查原因"><a href="#排查原因" class="headerlink" title="排查原因"></a>排查原因</h4><p>先看了预支付请求对接部门的返回，正常的结果。</p>
<p>不知道原因，但是看到不能拉起支付的请求，是同时请求了支付两次，而且302跳转不正常。<br>显示异常</p>
<pre><code>XMLHttpRequest cannot load ****支付url**** 
&apos;control-allow-origin&apos; header is present on the requested resource
</code></pre><p>查了下，是js跨域的异常，这时估计是什么原因导致浏览器302重定向失败了。也不知道为啥。</p>
<p>正常的支付流程</p>
<pre><code>    request                                      response

1.前端请求支付链接请求                        
                                            302响应，带着对接部门的支付链接
2.浏览器拿到302，请求对接部门支付链接        
                                            302响应，带着支付宝wap的支付链接
3.浏览器拿到302，请求支付宝wap的支付链接
                                            返回支付页面
</code></pre><p>现在流程2就爆出跨域问题了。。<br>怀疑同时请求两次导致的，直接将支付链接扔到浏览器上，查看浏览器请求，一次支付请求，重定向正常，拉起支付。</p>
<p>点击确认支付，同时请求两次支付请求，重定向异常，显示跨域异常，不能拉起支付。</p>
<p>找到问题所在。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>现在还不知道什么原因导致的，同时请求相同的302浏览器重定向失败。<br>明明好好查下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/08/mit-6-824-mapreduce-part1/" itemprop="url">
                  mit 6.824 mapreduce part1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-08T22:41:33+08:00" content="2016-07-08">
              2016-07-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式服务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式服务</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近忙着工作上的事，看书看论文的时间也少了，周五啦放松下，把最近做的分布式课程梳理下。</p>
<p>之前一直在做麻省理工大学的分布式课程mit 6.824<br>虽然一直做，但也只是做了个lab1中的前两个part</p>
<p>关于map reduce ，论文太多了。<br><a href="https://www.google.co.jp/url?sa=t&rct=j&q=&esrc=s&source=web&cd=4&ved=0ahUKEwiZ7qSUjuTNAhUFG5QKHaeXAN0QFgg3MAM&url=http%3A%2F%2Fresearch.google.com%2Farchive%2Fmapreduce-osdi04.pdf&usg=AFQjCNEL7nTxrQ6fiMUtt4AZh6gK5og2IQ&sig2=zGVJeyzqf4lryYhPlCqGkg" target="_blank" rel="external">google的官方论文</a></p>
<h3 id="part1-单机版顺序map-reduce"><a href="#part1-单机版顺序map-reduce" class="headerlink" title="part1 单机版顺序map reduce"></a>part1 单机版顺序map reduce</h3><p>mit给了部分map reduce执行的代码，包括测试用例，单机的多机的，任务失败的，不得不说，看看人家写的代码很有帮助，自己写的golang实在是搓。</p>
<h5 id="1-doMap-函数"><a href="#1-doMap-函数" class="headerlink" title="1.doMap 函数"></a>1.doMap 函数</h5><p>doMap函数:根绝master调用的输入文件，调用用户定义的map函数，然后将结果分区写到不同的out put file上。</p>
<p>如何分区，这个一开始没写好，一直测试不过，因为一次map reduce任务，有m个map任务，map任务取决于hdfs上block，n个reduce任务，这个取决于如何分区，这里没给分区函数，但测试用例初始化master的时候，file的个数决定map的个数，reduce的个数取决于给定的数量。</p>
<p>使用很简单的分区方式，对key进行hash后/reduce个数n取余<br>也就是hash(key)%nReduce得到分区文件</p>
<p>结果存储没啥好说的，一开始的建议是直接将输出的key value以json的形势存储文件，比较期待后边的倒排索引如何实现。</p>
<h5 id="2-doReduce-函数"><a href="#2-doReduce-函数" class="headerlink" title="2.doReduce 函数"></a>2.doReduce 函数</h5><p>doReduce函数:根据master的调用，拿到属于该reduce任务的分区文件，也就是hash(key)%nReduce，得到该分区下的所有的map函数产生的数据文件，读取合并排序后调用reduce函数，得到output key value ，json格式写文件。完活</p>
<h5 id="3-merge-函数"><a href="#3-merge-函数" class="headerlink" title="3.merge 函数"></a>3.merge 函数</h5><p>merge函数是mit给的，没有细看，大概就是把每个reduce，按照reduce的分区顺序合并，写入最后的结果文件中。</p>
<p>整体把map reduce的单机流程理清，最重要的还是如何实现分布式啦，如何处理map或者reduce函数的失败，hdfs的失败。</p>
<h3 id="part2-单机的word-count"><a href="#part2-单机的word-count" class="headerlink" title="part2 单机的word count"></a>part2 单机的word count</h3><p>根据刚才已经实现的map reduce框架，自己写map函数和reduce函数，有10多个文件，和测试代码，很简单与预计结果相同啦</p>
<h3 id="part3-分布式map-reduce"><a href="#part3-分布式map-reduce" class="headerlink" title="part3 分布式map reduce"></a>part3 分布式map reduce</h3><p>// TODO:</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/18/使用flume-伪分布式集群配置/" itemprop="url">
                  使用flume,伪分布式集群配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-18T08:10:42+08:00" content="2016-06-18">
              2016-06-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式服务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式服务</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="伪分布式搭建"><a href="#伪分布式搭建" class="headerlink" title="伪分布式搭建"></a>伪分布式搭建</h3><p>flume主要有0.9和1.6两个版本，这里使用0.9版本</p>
<pre><code>1.下载flume-0.9.4-cdh4.1.5
2.解压后进入到项目目录
3.执行bin/flume master,查看master可用http://host:35871/
4.另启一个终端执行bin/flume node，查看agent可用http://master:35862/
5.在http://host:35871/上，点config，提交一个配置
    configure node :    master(我机器的主机名)
    source         :    tail(&quot;/home/hadoop/flume_file/sourcefile&quot;)
    sink           :    text(&quot;/home/hadoop/flume_file/sinkfile&quot;)
6.回到配置主页面状态显示SUCCEEDED
7.现在向sourcefile追加内容，echo &apos;hello world&apos; &gt;&gt; sourcefile
8.查看同步的sinkfile，显示master [INFO Sat Jun 18 17:35:01 CST 2016] { tailSrcFile : sourcefile } hello world
</code></pre><p>这样使用flume中的agent，没有使用到collector，在本机器同步数据。</p>
<p>下篇测试多机部署数据同步。</p>
<p>下面关于flume中的master、node介绍是从官方文档翻译的，水平很有限，如有问题请见谅并指出<a href="https://github.com/whx4J8/whx4j8.github.io" target="_blank" rel="external">https://github.com/whx4J8/whx4j8.github.io</a></p>
<h3 id="非分布式模式"><a href="#非分布式模式" class="headerlink" title="非分布式模式"></a>非分布式模式</h3><p>flume有两种模式：<strong>flume master</strong> 和 <strong>flume node</strong></p>
<p>master控制节点的数据流，他是一个单一的逻辑实体，拥有全局的状态数据，并控制flume节点的数据流和监控flume 节点。flume 节点作为事件流的数据路径，它们可以是事件数据的来源、管道、和消费者。节点周期性的与master发送一个心跳，并获取它们的数据流配置。</p>
<h3 id="flume-master"><a href="#flume-master" class="headerlink" title="flume master"></a>flume master</h3><p>master可以通过下面的命令启动</p>
<pre><code>flume master
</code></pre><p>然后master开始运行，你可以使用浏览器访问，<strong>localhost:35871</strong>。此网页显示与master 联系的所有的flume node的状态。并且显示当前所分配的每个node的配置，当你启动这个flume 节点运行时，状态和配置表应该是空的。<br>该网页包含四个表，这些表中的信息代表当前flume中的全局状态。</p>
<pre><code>节点状态表
节点配置表
物理／逻辑节点映射表
命令历史表
</code></pre><p><strong>master节点状态表</strong>包含所有与master接触的flume节点的名称，和它们当前的配置版本（最初是无），它们的状态。每个flume节点的名称与Linux主机名相同。</p>
<p><strong>master节点配置表</strong>包含节点的逻辑名称，和分配给他的版本号，和他的source和sinks的规范。最初，这表是空的，但是在你更改值之后，你可以查看网页查看更新。有两组列，用户输入的version/source/sink。</p>
<p><strong>master物理/逻辑节点映射表</strong>包含了逻辑节点到它们的物理节点的映射。</p>
<p><strong>master命令历史记录表</strong>包含命令的状态。在一般的情况下，命令修改master全局状态。命令在master上被处理，并且分配一个唯一的命令标示号，每个命令有一个状态（成功、失败、挂起），一个命令行和一个尝试执行的消息。</p>
<h3 id="flume-node"><a href="#flume-node" class="headerlink" title="flume node"></a>flume node</h3><p>要启动flume node ， 在另一个终端执行命令</p>
<pre><code>flume node_nowatch
</code></pre><p>检查flume node，访问<strong>localhost:35862</strong>。每个节点在一个表上显示自己的数据，包括关于节点的诊断、统计数据、数据流和正在运行所在机器的系统度量。如果你有多个flume程序运行在一台机器上，他会自动的递增端口号，并尝试绑定下一个端口号，记录最终的选定的端口。</p>
<p>如果node已经运行，你应该重新刷新master 状态页，确保node与master联通。如果你新加入一个节点，你应该在主节点状态表中看到一个新的节点，在逻辑节点映射表中有一个新的条目，将逻辑节点关联物理节点。</p>
<h3 id="通过flume-master-配置-node"><a href="#通过flume-master-配置-node" class="headerlink" title="通过flume master 配置 node"></a>通过flume master 配置 node</h3><p>node节点可以与master接触，master可以得到她们的配置。使你可以不需要登录到远程机器修改配置后重启守护进程。你可以快速更改节点以前的数据流。</p>
<p>在master的页面，点击config连接。你有两种形式。这些都是web接口配置node 数据流。当flume node 连接到master，将被通知数据流version已经改变了，然后重新实例化，并且激活配置。</p>
<p>对于这个例子，可以在 configure a single node 中输入值，并且提交。</p>
<p>刷新master的页面，注意version、source、sink的改变。状态更新位active，他已经准备接受控制台数据了。<br>在master，一个节点可以有几种状态</p>
<pre><code>hello:一个新的node实例连接到master
idle:一个节点刚刚完成配置或者没有配置
configuring:一个节点已经收到一个配置，并且正在激活配置
active:一个节点正在积极的从源中提取数据，并且讲数据推到sink中
lost:节点与master失去联系
decommissioned:一个节点被故意退役从集群中
error:异常
</code></pre><p> 常见的配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">配置</th>
<th style="text-align:center">node name</th>
<th style="text-align:center">source</th>
<th style="text-align:center">sink</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">host</td>
<td style="text-align:center">tail(“/home/hadoop/flume_file/sourcefile”)</td>
<td style="text-align:center">console</td>
</tr>
</tbody>
</table>
<p>通过master改变系统中的不同节点的配置，从二获取从各种来源获取数据。</p>
<h3 id="Sink-介绍"><a href="#Sink-介绍" class="headerlink" title="Sink 介绍"></a>Sink 介绍</h3><p>flume有各种各样的来源，产生或接受新的事件消息进入系统。你能限制这些消息到控制台，如你所料。flume为不同的目的地提供各种各样的事件sink。<br>许多事件的目的地，可能是本地硬盘，hdfs，控制台，转发网络接口。你使用sink作为一个接口，发送事件。</p>
<p>通过指定中心的配置，并提交master，可以将不同的source连接到不同的sink上。</p>
<p>flume event sinks 事件接受器</p>
<pre><code>null                              没有，事件被删除
console[(&quot;format&quot;)]               控制台，格式可选
text(&quot;txtfile&quot;[,&quot;format&quot;])        文件
dfs(&quot;dfsfile&quot;)                    分布式文件系统
syslogTcp(&quot;host&quot;,port)            同步tcp端口
</code></pre><h3 id="分层flume节点：agent-和-collector"><a href="#分层flume节点：agent-和-collector" class="headerlink" title="分层flume节点：agent 和 collector"></a>分层flume节点：agent 和 collector</h3><p>如果通过网络发送事件是容易的、高效的、可靠的将是非常美好的。但是现实中，从分布式机器中和网络中收集数据，将极大的增加可能发生的事故和种类。底线是通过负责的策略保证可靠性。</p>
<p>flume 简化了这些问题，通过提供一个预定义的拓扑性和可靠性。只需要你为node节点设置一个角色。一个简单的flume node 的拓扑结构将node分为两个role。一个是flume agent 和flume collector。agent位于正在产生日志的机器上。例如你可以指定一个flume agent配置为syslogtcp为source，并且配置syslog 生成服务器发送日志到指定的本地端口。flume agent 会有一个agentSink作为他的sink配置，并且发送到collector。</p>
<p>collector集群侦听来自多个agent的数据记录，最终写到hdfs。<br>为了演示伪分布式模式下的新的sinks，你将实例化一个flume node在本地。为此，你需要在开始时配置一些额外的参数。下面的命令行启动一个物理节点名为collector</p>
<pre><code>flume node_nowatch -n collector
</code></pre><p>在master的页面上，你最中会看到两个节点，host和collector。flume node节点状态网页。在localhost:35862 localhost:35863。</p>
<p>端口绑定依赖实例化顺序，第一个物理节点初始化在35862、第二个初始化在35863</p>
<p>接着，collector承担起收集器的角色，通过使用聚集多配置的方式，数据从控制台发送到collector中。将agent使用agentsink，一个高可靠的网络sink。collector 节点的source配置为collectorSource同时他的source配置为console</p>
<pre><code>host : console | agentSink(&quot;localhost&quot;,35853) ;
collector : collectorSource(35853) | console ;
</code></pre><p>当你在终端输入，事件被发送到collector。现在当消息到达collector时，大概有一定的延迟15s左右，这实际上是一个可配置的默认的设置的值，但测试时同步的延迟没有这么高。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/16/理解flume/" itemprop="url">
                  理解flume
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-16T18:08:00+08:00" content="2016-06-16">
              2016-06-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式服务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式服务</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>线上使用flume同步日志到hdfs和es，一直没有机会看，现在来看下flume日志同步工具的大体设计</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>flume 是一套分布的高可用的日志传输组件，有效的移动大量的数据。<br>flume日志设计简单、坚固、灵活。主要描述一个面向流的数据流，数据流描述一个单一的数据流的传输和处理，从数据的生成到最终目的。<br>由逻辑节点组成，可以将接受的事件转换或者聚合。逻辑节点节点链接在一起形成数据流。<br>控制这些的是master节点，一个单独的服务。记录着flume所有的物理和逻辑节点。master分配逻辑节点，并且负责所有的逻辑节点配置更新，反过来逻辑节点定期的联系master节点，所以它们可以共享信息，并且检查更新它们的配置信息</p>
<p>典型的flume，由一组逻辑节点部署，分为三层。代理节点通常安装在产生日志的机器上，作为数据与flume的接触点，并且将数据转发到collector层，然后存储到最后的存储层。代理层可以监听系统log，或者由web服务、Hadoop产生的日志。代理产生的数据流发送给collector，collector然后讲数据汇聚成较大的流写入hdfs</p>
<p>逻辑节点是一个非常灵活的抽象。每个逻辑节点都有2个组件，一个source源和一个sink接收器。source告诉逻辑节点那里收集数据，然后sink告诉逻辑节点发送数据到哪里。逻辑节点唯一的区别就是如何配置source和sink。它们还可以对数据进行简单的处理。在前面的例子中，collector 和 agent 运行在相同节点的软件。master分配一个配置给每个逻辑节点，一个节点的所有组件在运行时被动态分配，flume服务无需重启任何java进程的情况下它们的配置可以被修改很多次。</p>
<p>source sink optional decorator 是强大的源语。flume保证每个流数据的属性，活着计算事件元数据，甚至产生新的事件插入到流数据中。一个逻辑节点同样可以发送数据流到多个逻辑节点。这允许多个流，每个字流可以配置不同。有可能一个流是一个集合路径，可靠的传送一个持久性存储的数据，另一个流计算轻量级的分析，提供一个报警系统。</p>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>可靠性，在不丢失数据的过程中继续传递事件。大型分布式系统可以在许多方面遭受故障，硬件、网络、内存、软件崩溃、运行缓慢。flume将容错作为核心设计。保持运行和收集数据，即使许多组件都失败了。</p>
<p>flume保证的一个agent所接受到的数据只要保证agent node运行最后都会执行到collector，数据可以可靠的传输到最终目的地。<br>但是，可靠的交付需要相当多的资源，往往一些数据需要更强大的保证。因此flume指定三个支持的可靠级别<br>     1.端到端<br>     2.存储故障<br>     3.最大的努力</p>
<h3 id="可靠性说明"><a href="#可靠性说明" class="headerlink" title="可靠性说明"></a>可靠性说明</h3><p>虽然flume 及其容忍机器、网络、软件故障，从来没有任何这样的100％可靠性。如果flume所安装在的机器都发生了不可逆转的破坏，水槽数据的副本都丢失了，就无法恢复了</p>
<p>end-to-end 端到端级别的可靠性保证一旦flume一旦接受一个事件，该事件使她的断点，只要agent接受到event，将会被保持很长的时间。首先agent先写事件到硬盘的write－ahead log。如果代理崩溃或者重新启动，该事件不会被丢失。然后事件根据流程成功的发送到结束位置。一个确认ack被发送回原agent，以便他知道不需要将事件存储在磁盘上。这个可靠性水平可以承受任何数量的下游代理的故障。</p>
<p>store on failure 失败存储级别，需要节点将数据发送给下游节点的时候返回一个ack包，保证成功。如果发送节点发现失败，他将数据存储到节点所在的硬盘上，直到下游节点的修复，或者选择另一个下游的目的地。虽然这是有效的，如果上游发送数据进程挂了，数据可能丢失。</p>
<p>best-effort 最低的保证级别，数据从上游发送到下游节点没有任何的确认和重试交付。如果节点失败，他们发送的任何数据都会丢失。</p>
<p>消除单点<br>尽管使用端到端级别的可靠性水平，一个flume 流如果没有任何节点处理事件也是不可能有进展的。数据将会继续被agents收集，但是代理可能无法找到一个合适数据流下游，直到找到一个合适的在线节点。为了保持高可用性，flume允许没有任何用户的干预下入，若是发送到下游失败，则就去找另外的下游节点。flume的master进程也是可以被复制的高可用的，这意味着数据层和控制层都可以容忍一些故障。</p>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>可扩展性是通过向系统中添加更多的资源来提高系统性能的能力。flume的目标是横向扩展，逐步添加更年多的机器，系统增加吞吐量能力。在flume中的一个关键性能指标是进入系统的数量或大小，并被交付。当负荷增加时，很简单，讲更多的资源添加到系统中，以增加更多的负荷量</p>
<p>有三个独立的组件组成的flume需要有不同的方法增加可扩展性：collector层，master，storage层</p>
<p>collector层需要能够扩展一处理大量的来自大量的代理节点的数据。通过在collector层添加更多的机器。可以增加系统的数量和最大的可用吞吐量。</p>
<p>一个单独的collector通常可以处理许多agent节点，因为每个单独的agent产生的日志，与collector的全部带宽相比，只是非常小的一部分。因此flume平衡流分配到不同的collector节点中。flume采用随机算法均匀的分配到collector list。这会自动传播负载，而且还能保持collector失败的情况下，传播负载。</p>
<p>由于系统中的节点增加，master节点在控制路径上的传输可能成为瓶颈。flume的master还可以通过更多的机器来支持横向扩展，虽然只是少数的商品服务器可以提供大良的节点安装。flume的master的状态保持同步和完全复制，这确保了他是容错和高度可扩展的。</p>
<h3 id="可管理性"><a href="#可管理性" class="headerlink" title="可管理性"></a>可管理性</h3><p>可管理性是控制数据流、监控节点、修改配置，控制输出到大型系统的一个能力。手动管理源点到终点是繁琐的容易出错的，另一个主要的痛点，又可能成千上万的日志生成应用程序和服务。他是一个重要集中管理点，监测和改变数据流，以及动态处理不同条件或问题的能力。</p>
<p>flume 的master是管理全局数据流状态的一点。痛殴master，用户可以监控流程和配置属性。master要求自动响应系统的比阿花，如负载不平衡，部分失败或者重新配置的硬件。</p>
<p>你可以利用master重新配置节点。虽然本博客描述的是传统的三层部署的例子。节点的灵活性允许任意节点的拓扑。你可以通过主界面提交一个采用数据流规范编写的小脚本重新配置节点。</p>
<p>你可以通过两个接口管理master：web接口或者flume的shell脚本。web接口提供交互式式的系统的状态，shell提供人工编写的脚本或机器生成的脚本管理。</p>
<h3 id="功能扩展性"><a href="#功能扩展性" class="headerlink" title="功能扩展性"></a>功能扩展性</h3><p>可扩展性是添加性功能到系统中大的能力。可以通过增加链接到现有存储层或者数据平台的flume。通过简单的接口就可以实现，功能设计到简单组件的分离，流程规范语言，和一个简单而灵活的数据模型。</p>
<p>flume提供特别的可靠性和资源性能的组件。一般来自从文件系统中的文件，系统日志和syslog－ng或者标准输出的一个过程。同样有很多的事件输出目的地。虽然hdfs是主要的输出地，但是事件也可以被发送到本地，或者监控和报警等渠道。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/12/idea内嵌git不可用问题解决/" itemprop="url">
                  idea内嵌git不可用问题解决
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-12T11:56:44+08:00" content="2016-06-12">
              2016-06-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="idea中使用内嵌git插件"><a href="#idea中使用内嵌git插件" class="headerlink" title="idea中使用内嵌git插件"></a>idea中使用内嵌git插件</h4><p>以前使用idea中的git比较习惯，也用过source tree、小乌龟一些插件。麻烦，总要切出去切回来。也不想用命令行，对比代码revert不方便。</p>
<p>个人比较懒就喜欢用idea自带的git插件和一些简单git的命令。</p>
<p>重装系统之后，导入项目。idea中的git插件确一直不可用<br>git插件不可用的状态没有git:master的显示</p>
<p><img src="/images/ide_git_not_allow.png" alt="idea git 提示"></p>
<p>解决方式:正确的导入maven项目<br>1.选择一个项目目录，mkdir directory<br>2.cd directory, git init初始化一个git目录<br>3.在这个git目录拉取maven项目<br>4.重启idea<br>5.idea会提示unregistered vcs roots detected如图，选择add roots</p>
<p><img src="/images/idea_git_warn.png" alt="idea git 提示"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/Linux-File-System总体介绍/" itemprop="url">
                  Linux File System 总体介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T18:22:39+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> <strong>On a UNIX system, everything is a file; if something is not a file, it is a process</strong> </p>
<h4 id="文件的种类"><a href="#文件的种类" class="headerlink" title="文件的种类"></a>文件的种类</h4><blockquote>
<ul>
<li>目录文件:存放其他文件的文件</li>
<li>特殊文件:用于输入输出机制，大多数特殊文件在/dev中</li>
<li>链接:系统使文件在系统的file tree中多处可见</li>
<li>socket:特殊的文件类型，类似tcp socket，通过文件系统提供受保护的进程网络连接</li>
<li>命名管道:不使用网络套接字，进程间通信的一种方式</li>
</ul>
</blockquote>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>在发生故障的情况下，硬盘被分区可以保证更高的数据安全性。通过硬盘分区，可以将数据分组分离，当事故发生，只有被命中分区的数据被破坏，其他分区的数据被保存下来。</p>
<p>例如：若整个系统为一个分区，应用程序将分区硬盘写满了，程序不能再执行，整个系统也将停止。如果数据单独存放到一个数据分区上，受影响的也仅仅是数据分区，系统分区和其他的分区正常使用。</p>
<p>两种分区：</p>
<pre><code>1. 数据分区，包含启动和执行系统的根目录
2. swap分区，扩展计算的物理内存，在硬盘上的额外内存    
</code></pre><h5 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h5><p>大多数系统包含一个根分区，一个或者多个数据分区，一个或多个交换分区。并且Linux系统使用fdisk安装分区的类型。</p>
<p>标准根分区约为100-500 MB，包含系统的配置文件，基本的命令，服务器程序，系统函数库，一些临时空间和管理用户的主目录</p>
<p>内核是一个单独的分区，他是系统中最重要的文件。你可以查看你的/boot，用来保持内核执行，和相应的文件。</p>
<p>硬盘的其他数据都被分在数据分区，尽管有可能仅仅是一个分区。在Linux中</p>
<blockquote>
<ul>
<li>/usr 用户的程序</li>
<li>/home 用户的个人数据</li>
<li>/var 存储临时文件和mail队列</li>
<li>/opt 三方或者额外的软件</li>
</ul>
</blockquote>
<h5 id="swap分区"><a href="#swap分区" class="headerlink" title="swap分区"></a>swap分区</h5><p>交换空间仅适用于系统本身的访问，隐藏于正常的操作，是工作的保障。在Linux上从未看过内存已满的异常也是因为swap的功劳。<br>一般Linux在使用swap的时候，硬盘和内存的转换约为2:1。就是说一个系统如果需要512M的swap内存空间。三种方案：</p>
<blockquote>
<ul>
<li>一个1g的分区</li>
<li>2个512m的分区</li>
<li>2个硬盘分别512m的分区</li>
</ul>
</blockquote>
<p>最后的适用于大量的io操作。</p>
<p>一旦分区创建成功，你只能添加。虽然可以改变已有的分区大小，但是并不建议<br>服务器上的往往是用户数据和系统数据分离。提供服务的程序和程序的数据分离</p>
<h4 id="挂载点"><a href="#挂载点" class="headerlink" title="挂载点"></a>挂载点</h4><p>所有的分区通过一个挂载点连接到系统，挂载点定义在文件系统中的特定数据组的位置，通常所有的分区通过根分区链接，在这个分区中用/根目录表示。这些空目录件是链接到这些分区的起始点</p>
<p>例如我们想将分区链接到/opt/media的目录中，首先系统中/opt/media这个目录是必须存在的，并且最好是一个空的目录，然后使用mount命令，将分区添加到系统中。当你看以前的空的目录/opt/media,会包含一些媒介的文件或者目录。</p>
<p>在一个正在运行的系统中</p>
<blockquote>
<ul>
<li>df -h    命令显示有关分区和挂载点的信息</li>
<li>df -h .  查看自己当前目录所在的分区</li>
</ul>
</blockquote>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>每个分区都有自己的文件系统，通过想象这些文件系统连接在一起，可以看到整个系统的树状结构。<br>在一个文件系统中，一个文件由一个inode表示，一个包含文件具体信息的序列号，文件所属，文件在硬盘上的位置</p>
<p>每个分区都有自己的索引节点，在同一个系统中的多个文件系统中，可以有相同的inode编号<br>每个inode都是描述文件在硬盘上的数据结构，存储文件的属性。包含文件数据的物理位置，当一个硬盘初始化并接受数据存储，通常在初始化安装系统或者添加额外的硬盘时候，指定固定的inode的数量，这个值限制文件的最大数量，一个inode大约2到8kb存储</p>
<p>在创建一个文件时候，得到一个新的空闲的inode。包含信息</p>
<blockquote>
<ul>
<li>文件的所有者</li>
<li>文件类型</li>
<li>权限</li>
<li>创建、修改日期</li>
<li>连接号 连接到这个文件的</li>
<li>文件大小</li>
<li>定位到硬盘的实际物理地址</li>
</ul>
</blockquote>
<p>有些数据不包含在inode中，文件名和目录。这些都被存储在目录文件中，通过对比文件名和inode编号，可以构成一个树状系统。用户可以使用ls -i显示inode编号，inode在硬盘上有独立的空间存储。</p>
<h4 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h4><p><a href="http://www.tldp.org/LDP/intro-linux/html/sect_03_01.html" target="_blank" rel="external">http://www.tldp.org/LDP/intro-linux/html/sect_03_01.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/14/guarded-suspension-要等我准备好呦/" itemprop="url">
                  guarded suspension-要等我准备好呦
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-14T11:01:20+08:00" content="2016-05-14">
              2016-05-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="多线程-guarded-suspension-模式"><a href="#多线程-guarded-suspension-模式" class="headerlink" title="多线程 guarded suspension 模式"></a>多线程 guarded suspension 模式</h4><p>在java多线程设计模式这本书中，提及到guarded suspension模式。<br>这种模式应用在”你要等我准备好哦”这种情况下。表明某个状态正在被保护着，不能对其进行操作。</p>
<p>举个🌰，模拟一个http服务器的交互<br>1.客户端提交request到服务端<br>2.服务端接受到request放在requestQueue中<br>3.服务端处理request</p>
<p>首先需要一个RequestQueue,用来存放request对象,这个队列同时被客户端和服务端操作。</p>
<pre><code>public class RequestQueue {

    private final LinkedList&lt;Request&gt; queue = new LinkedList();

    public synchronized Request getRequest(){
        while(queue.size() &lt;= 0){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return queue.removeFirst();
    }

    public synchronized void putRequest(Request request){
        queue.addLast(request);
        notifyAll();
    }

}
</code></pre><p>然后是ClientThread向队列中put request对象</p>
<pre><code>public class ClientThread extends Thread {

    private Random random;
    private final RequestQueue requestQueue;

    public ClientThread(RequestQueue requestQueue, String name, long seed) {
        super(name);
        this.random = new Random(seed);
        this.requestQueue = requestQueue;
    }

    @Override
    public void run() {

        int requestNum = 10000;
        for (int i = 0; i &lt; requestNum; i++){
            Request request = new Request(&quot;No.&quot; + i);
            log(Thread.currentThread().getName() + &quot; requests &quot; + request);
            requestQueue.putRequest(request);
            doSomeThing();
        }

    }

    private void log(String log){
        System.out.println(log);
    }

    private void doSomeThing(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>ServerThread从队列中拿出request进行处理</p>
<pre><code>public class ServerThread extends Thread {

    private Random random;
    private final RequestQueue requestQueue;

    public ServerThread(RequestQueue requestQueue, String name, long seed) {
        super(name);
        this.random = new Random(seed);
        this.requestQueue = requestQueue;
    }

    @Override
    public void run() {

        int requestNum = 10000;
        for (int i = 0; i &lt; requestNum; i++) {
            Request request = requestQueue.getRequest();
            log(Thread.currentThread().getName() + &quot; handles &quot; + request);
            doSomeThing();
        }

    }

    private void log(String log) {
        System.out.println(log);
    }

    private void doSomeThing() {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>Main 中执行完整的运行</p>
<pre><code>public class Main {

    public static void main(String[] args){
        RequestQueue requestQueue = new RequestQueue();
        new ClientThread(requestQueue,&quot;client thread&quot;,2323423l).start();
        new ServerThread(requestQueue,&quot;server thread-demo1&quot;,9292822l).start();
        new ServerThread(requestQueue,&quot;server thread-2&quot;,9292822l).start();
        new ServerThread(requestQueue,&quot;server thread-3&quot;,9292822l).start();
        new ServerThread(requestQueue,&quot;server thread-4&quot;,9292822l).start();
        new ServerThread(requestQueue,&quot;server thread-5&quot;,9292822l).start();
    }
}
</code></pre><p>RequestQueue里封装了一个LinkedList对象放出request对象<br>getRequest方法,从queue队列头中获取一个request对象,getRequest方法必须在queue中值时才能正确的执行。</p>
<p>一般这种情况都是有两种模式轮训和事件通知,很明显的是基于轮训的方式无端的消耗着cpu时间片。所以使用后者,guarded suspension 模式也是基于此实现的。</p>
<p>目的：从queue中取得request<br>条件：queue.size() &gt; 0</p>
<p>使用synchronized,wait方式,首先若是不满足条件进入while,调用wait(),线程进入到对象的wait set中,等待其他线程对该对象notify</p>
<p>其他线程在什么情况下对其notify呢？看条件变量queue.size() &gt; 0,queue的size大于0时，也就是putRequest的时候</p>
<p>现在已经知道什么时候去wait，什么时候去notify了。<br>可为什么要加synchronized同步呢，这个以后再进行详细说明。简单介绍下<br>在线程调用object.wait方法时候,会把当前线程防到wait set中（虚拟概念）,并且该线程进入Wait状态<br>在线程调用object.notify方法的时候，会把object的 wait set中的一个线程唤醒<br>多个线程同时处理共享的变量域，所以需要加synchronized同步。</p>
<p>现在回来，当其他线程调用putRequest的时候，并且同步锁释放了，之前调用因getRequest方法处于Wait状态的线程获取到了锁,进行后续操作,好有问题!!!看代码</p>
<pre><code>public synchronized Request getRequest(){
    while(queue.size() &lt;= 0){
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    return queue.removeFirst();
}
</code></pre><p>synchronized方法并没有执行完,不应该释放同步锁，为什么putRequest方法可以获取到锁，并且执行?</p>
<p>stackoverflow原文</p>
<p>“Invoking wait inside a synchronized method is a simple way to acquire the intrinsic lock”</p>
<p>This sentence is false, it is an error in documentation.</p>
<p>Thread acquires the intrinsic lock when it enters a synchronized method. Thread inside the synchronized method is set as the owner of the lock and is in RUNNABLE state. Any thread that attempts to enter the locked method becomes BLOCKED.</p>
<p>When thread calls wait it releases the current object lock (it keeps all locks from other objects) and than goes to WAITING state.</p>
<p>When some other thread calls notify or notifyAll on that same object the first thread changes state from WAITING to BLOCKED, Notified thread does NOT automatically reacquire the lock or become RUNNABLE, in fact it must fight for the lock with all other blocked threads.</p>
<p>WAITING and BLOCKED states both prevent thread from running, but they are very different.</p>
<p>WAITING threads must be explicitly transformed to BLOCKED threads by a notify from some other thread.</p>
<p>WAITING never goes directly to RUNNABLE.</p>
<p>When RUNNABLE thread releases the lock (by leaving monitor or by waiting) one of BLOCKED threads automatically takes its place.</p>
<p>So to summarize, thread acquires the lock when it enters synchronized method or when it reenters the synchronized method after the wait.</p>
<pre><code>public synchronized guardedJoy() {
    // must get lock before entering here
    while(!joy) {
        try {
            wait(); // releases lock here
            // must regain the lock to reentering here
        } catch (InterruptedException e) {}
    }
    System.out.println(&quot;Joy and efficiency have been achieved!&quot;);
}
</code></pre><p>也就是说进入guardedJoy方法时候需要获取到锁<br>当调用wait方法时会释放锁,线程从Runnable进入Wait<br>当其他线程调用notify<br>线程从Wait进入Blocking<br>这时候需要获取到同步锁才能进行Runnable<br>明白了</p>
<p>整理一下guarded suspension 模式</p>
<p>1.一个具有状态的对象,这个对象被多个线程同时访问,这个对象只有在自己的状态合适的时候,才会让线程进行某些处理<br>2.使用警戒条件来表示对象的状态，并且在目的处理前,测试满足条件不满足则进行wait,满足则执行处理方法<br>3.用notify方法通知wait中的线程表明状态已经满足了，wait中的线程进入blocking获得锁后执行操作</p>
<p>参考代码：</p>
<pre><code>https://github.com/whx4J8/Thread.git
</code></pre><p>参考文献：</p>
<blockquote>
<p>java多线程设计模式第3章<br>stackoverflow : <a href="http://stackoverflow.com/questions/13249835/java-does-wait-release-lock-from-synchronized-block" target="_blank" rel="external">http://stackoverflow.com/questions/13249835/java-does-wait-release-lock-from-synchronized-block</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/16/Hadoop安装-准备环境/" itemprop="url">
                  Hadoop安装-准备环境
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-16T13:17:45+08:00" content="2016-04-16">
              2016-04-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式计算/" itemprop="url" rel="index">
                    <span itemprop="name">分布式计算</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>首先准备3台机器，这里和小伙伴一起买了三台阿里云</p>
<p>1.为每台机器添加hadoop用户组，添加hadoop用户</p>
<pre><code>sudo groupadd hadoop
sudo useradd -g hadoop
sudo passwd hadoop    
</code></pre><p>2.为每台机器的hadoop配置sshkey</p>
<pre><code>sudo su - hadoop
cd ~/.ssh                没有.ssh目录使用ssh-keygen生成
将三台机器的id_rsa.pub公钥拷贝到.ssh/authorized_keys中，若没有该文件touch一个
务必保证每台机器使用hadoop用户可以ssh登录到其他机器上
这里使用注意的是authorized_keys文件必须要有600权限
</code></pre><p>3.配置host</p>
<pre><code>***.***.***.*** master
***.***.***.*** slave01
***.***.***.*** slave02
</code></pre><p>3.下载hadoop，配置环境变量</p>
<pre><code>cd ~
wget https://archive.apache.org/dist/hadoop/core/hadoop-2.2.0/hadoop-2.2.0.tar.gz
</code></pre><p>解压后设置环境变量</p>
<pre><code>vim ~/.bashrc

export HADOOP_PREFIX=$HOME/local/opt/hadoop-2.2.0
export HADOOP_COMMON_HOME=$HADOOP_PREFIX
export HADOOP_HDFS_HOME=$HADOOP_PREFIX
export HADOOP_MAPRED_HOME=$HADOOP_PREFIX
export HADOOP_YARN_HOME=$HADOOP_PREFIX
export HADOOP_CONF_DIR=$HADOOP_PREFIX/etc/hadoop
export PATH=$PATH:$HADOOP_PREFIX/bin:$HADOOP_PREFIX/sbin
</code></pre><p>srouce ~/.bash_profile 使之生效，这样的好处不会污染其他用户的环境变量</p>
<pre><code>echo $HADOOP_PREFIX
/home/hadoop/local/opt/hadoop-2.2.0
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/09/effective-java-读书笔记-类和接口/" itemprop="url">
                  effective java 读书笔记-类和接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-09T20:19:43+08:00" content="2016-04-09">
              2016-04-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="复用建议：组合优先于继承"><a href="#复用建议：组合优先于继承" class="headerlink" title="复用建议：组合优先于继承"></a>复用建议：组合优先于继承</h4><p>如果需要复用代码，我们第一想到的是使用继承，但是这只是面向对象的一种复用方式－ 白盒复用。<br>子类继承父类，父类中的实现对子类可见，若是父类的实现代码改变，子类代码也就需要跟着改变。<br>另一种方式，对象组合－黑盒复用。对象组合要求对象之间定义好接口，相互之间使用接口引用。对象内部的实现是不可见的。</p>
<p>因为继承父类，父类的实现对子类完全可见甚至可改变，所以父类中的任何一个改变都有可能影响到子类，这样破坏了封装性，代码非常脆弱。<br>而使用组合的方式，对象之间使用接口的方式进行调用。接口的实现改变了，但并不影响接口外部的调用，这样的代码非常稳固，复用性高</p>
<p>使用原则：大多数情况下，组合方式优先于继承，使用这种方式的代码更容易维护。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="whx4J8" />
          <p class="site-author-name" itemprop="name">whx4J8</p>
          <p class="site-description motion-element" itemprop="description">github.com/whx4J8</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">whx4J8</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
