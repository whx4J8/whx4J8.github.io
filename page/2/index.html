<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="github.com/whx4J8">
<meta property="og:type" content="website">
<meta property="og:title" content="学而后知不足">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="学而后知不足">
<meta property="og:description" content="github.com/whx4J8">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学而后知不足">
<meta name="twitter:description" content="github.com/whx4J8">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>

  <title> 学而后知不足 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">学而后知不足</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/14/guarded-suspension-要等我准备好呦/" itemprop="url">
                  guarded suspension-要等我准备好呦
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-14T11:01:20+08:00" content="2016-05-14">
              2016-05-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="多线程-guarded-suspension-模式"><a href="#多线程-guarded-suspension-模式" class="headerlink" title="多线程 guarded suspension 模式"></a>多线程 guarded suspension 模式</h4><p>在java多线程设计模式这本书中，提及到guarded suspension模式。<br>这种模式应用在”你要等我准备好哦”这种情况下。表明某个状态正在被保护着，不能对其进行操作。</p>
<p>举个🌰，模拟一个http服务器的交互<br>1.客户端提交request到服务端<br>2.服务端接受到request放在requestQueue中<br>3.服务端处理request</p>
<p>首先需要一个RequestQueue,用来存放request对象,这个队列同时被客户端和服务端操作。</p>
<pre><code>public class RequestQueue {

    private final LinkedList&lt;Request&gt; queue = new LinkedList();

    public synchronized Request getRequest(){
        while(queue.size() &lt;= 0){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return queue.removeFirst();
    }

    public synchronized void putRequest(Request request){
        queue.addLast(request);
        notifyAll();
    }

}
</code></pre><p>然后是ClientThread向队列中put request对象</p>
<pre><code>public class ClientThread extends Thread {

    private Random random;
    private final RequestQueue requestQueue;

    public ClientThread(RequestQueue requestQueue, String name, long seed) {
        super(name);
        this.random = new Random(seed);
        this.requestQueue = requestQueue;
    }

    @Override
    public void run() {

        int requestNum = 10000;
        for (int i = 0; i &lt; requestNum; i++){
            Request request = new Request(&quot;No.&quot; + i);
            log(Thread.currentThread().getName() + &quot; requests &quot; + request);
            requestQueue.putRequest(request);
            doSomeThing();
        }

    }

    private void log(String log){
        System.out.println(log);
    }

    private void doSomeThing(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>ServerThread从队列中拿出request进行处理</p>
<pre><code>public class ServerThread extends Thread {

    private Random random;
    private final RequestQueue requestQueue;

    public ServerThread(RequestQueue requestQueue, String name, long seed) {
        super(name);
        this.random = new Random(seed);
        this.requestQueue = requestQueue;
    }

    @Override
    public void run() {

        int requestNum = 10000;
        for (int i = 0; i &lt; requestNum; i++) {
            Request request = requestQueue.getRequest();
            log(Thread.currentThread().getName() + &quot; handles &quot; + request);
            doSomeThing();
        }

    }

    private void log(String log) {
        System.out.println(log);
    }

    private void doSomeThing() {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>Main 中执行完整的运行</p>
<pre><code>public class Main {

    public static void main(String[] args){
        RequestQueue requestQueue = new RequestQueue();
        new ClientThread(requestQueue,&quot;client thread&quot;,2323423l).start();
        new ServerThread(requestQueue,&quot;server thread-demo1&quot;,9292822l).start();
        new ServerThread(requestQueue,&quot;server thread-2&quot;,9292822l).start();
        new ServerThread(requestQueue,&quot;server thread-3&quot;,9292822l).start();
        new ServerThread(requestQueue,&quot;server thread-4&quot;,9292822l).start();
        new ServerThread(requestQueue,&quot;server thread-5&quot;,9292822l).start();
    }
}
</code></pre><p>RequestQueue里封装了一个LinkedList对象放出request对象<br>getRequest方法,从queue队列头中获取一个request对象,getRequest方法必须在queue中值时才能正确的执行。</p>
<p>一般这种情况都是有两种模式轮训和事件通知,很明显的是基于轮训的方式无端的消耗着cpu时间片。所以使用后者,guarded suspension 模式也是基于此实现的。</p>
<p>目的：从queue中取得request<br>条件：queue.size() &gt; 0</p>
<p>使用synchronized,wait方式,首先若是不满足条件进入while,调用wait(),线程进入到对象的wait set中,等待其他线程对该对象notify</p>
<p>其他线程在什么情况下对其notify呢？看条件变量queue.size() &gt; 0,queue的size大于0时，也就是putRequest的时候</p>
<p>现在已经知道什么时候去wait，什么时候去notify了。<br>可为什么要加synchronized同步呢，这个以后再进行详细说明。简单介绍下<br>在线程调用object.wait方法时候,会把当前线程防到wait set中（虚拟概念）,并且该线程进入Wait状态<br>在线程调用object.notify方法的时候，会把object的 wait set中的一个线程唤醒<br>多个线程同时处理共享的变量域，所以需要加synchronized同步。</p>
<p>现在回来，当其他线程调用putRequest的时候，并且同步锁释放了，之前调用因getRequest方法处于Wait状态的线程获取到了锁,进行后续操作,好有问题!!!看代码</p>
<pre><code>public synchronized Request getRequest(){
    while(queue.size() &lt;= 0){
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    return queue.removeFirst();
}
</code></pre><p>synchronized方法并没有执行完,不应该释放同步锁，为什么putRequest方法可以获取到锁，并且执行?</p>
<p>stackoverflow原文</p>
<p>“Invoking wait inside a synchronized method is a simple way to acquire the intrinsic lock”</p>
<p>This sentence is false, it is an error in documentation.</p>
<p>Thread acquires the intrinsic lock when it enters a synchronized method. Thread inside the synchronized method is set as the owner of the lock and is in RUNNABLE state. Any thread that attempts to enter the locked method becomes BLOCKED.</p>
<p>When thread calls wait it releases the current object lock (it keeps all locks from other objects) and than goes to WAITING state.</p>
<p>When some other thread calls notify or notifyAll on that same object the first thread changes state from WAITING to BLOCKED, Notified thread does NOT automatically reacquire the lock or become RUNNABLE, in fact it must fight for the lock with all other blocked threads.</p>
<p>WAITING and BLOCKED states both prevent thread from running, but they are very different.</p>
<p>WAITING threads must be explicitly transformed to BLOCKED threads by a notify from some other thread.</p>
<p>WAITING never goes directly to RUNNABLE.</p>
<p>When RUNNABLE thread releases the lock (by leaving monitor or by waiting) one of BLOCKED threads automatically takes its place.</p>
<p>So to summarize, thread acquires the lock when it enters synchronized method or when it reenters the synchronized method after the wait.</p>
<pre><code>public synchronized guardedJoy() {
    // must get lock before entering here
    while(!joy) {
        try {
            wait(); // releases lock here
            // must regain the lock to reentering here
        } catch (InterruptedException e) {}
    }
    System.out.println(&quot;Joy and efficiency have been achieved!&quot;);
}
</code></pre><p>也就是说进入guardedJoy方法时候需要获取到锁<br>当调用wait方法时会释放锁,线程从Runnable进入Wait<br>当其他线程调用notify<br>线程从Wait进入Blocking<br>这时候需要获取到同步锁才能进行Runnable<br>明白了</p>
<p>整理一下guarded suspension 模式</p>
<p>1.一个具有状态的对象,这个对象被多个线程同时访问,这个对象只有在自己的状态合适的时候,才会让线程进行某些处理<br>2.使用警戒条件来表示对象的状态，并且在目的处理前,测试满足条件不满足则进行wait,满足则执行处理方法<br>3.用notify方法通知wait中的线程表明状态已经满足了，wait中的线程进入blocking获得锁后执行操作</p>
<p>参考代码：</p>
<pre><code>https://github.com/whx4J8/Thread.git
</code></pre><p>参考文献：</p>
<blockquote>
<p>java多线程设计模式第3章<br>stackoverflow : <a href="http://stackoverflow.com/questions/13249835/java-does-wait-release-lock-from-synchronized-block" target="_blank" rel="external">http://stackoverflow.com/questions/13249835/java-does-wait-release-lock-from-synchronized-block</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/16/Hadoop安装-准备环境/" itemprop="url">
                  Hadoop安装-准备环境
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-16T13:17:45+08:00" content="2016-04-16">
              2016-04-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式计算/" itemprop="url" rel="index">
                    <span itemprop="name">分布式计算</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>首先准备3台机器，这里和小伙伴一起买了三台阿里云</p>
<p>1.为每台机器添加hadoop用户组，添加hadoop用户</p>
<pre><code>sudo groupadd hadoop
sudo useradd -g hadoop
sudo passwd hadoop    
</code></pre><p>2.为每台机器的hadoop配置sshkey</p>
<pre><code>sudo su - hadoop
cd ~/.ssh                没有.ssh目录使用ssh-keygen生成
将三台机器的id_rsa.pub公钥拷贝到.ssh/authorized_keys中，若没有该文件touch一个
务必保证每台机器使用hadoop用户可以ssh登录到其他机器上
这里使用注意的是authorized_keys文件必须要有600权限
</code></pre><p>3.配置host</p>
<pre><code>***.***.***.*** master
***.***.***.*** slave01
***.***.***.*** slave02
</code></pre><p>3.下载hadoop，配置环境变量</p>
<pre><code>cd ~
wget https://archive.apache.org/dist/hadoop/core/hadoop-2.2.0/hadoop-2.2.0.tar.gz
</code></pre><p>解压后设置环境变量</p>
<pre><code>vim ~/.bashrc

export HADOOP_PREFIX=$HOME/local/opt/hadoop-2.2.0
export HADOOP_COMMON_HOME=$HADOOP_PREFIX
export HADOOP_HDFS_HOME=$HADOOP_PREFIX
export HADOOP_MAPRED_HOME=$HADOOP_PREFIX
export HADOOP_YARN_HOME=$HADOOP_PREFIX
export HADOOP_CONF_DIR=$HADOOP_PREFIX/etc/hadoop
export PATH=$PATH:$HADOOP_PREFIX/bin:$HADOOP_PREFIX/sbin
</code></pre><p>srouce ~/.bash_profile 使之生效，这样的好处不会污染其他用户的环境变量</p>
<pre><code>echo $HADOOP_PREFIX
/home/hadoop/local/opt/hadoop-2.2.0
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/09/effective-java-读书笔记-类和接口/" itemprop="url">
                  effective java 读书笔记-类和接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-09T20:19:43+08:00" content="2016-04-09">
              2016-04-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="复用建议：组合优先于继承"><a href="#复用建议：组合优先于继承" class="headerlink" title="复用建议：组合优先于继承"></a>复用建议：组合优先于继承</h4><p>如果需要复用代码，我们第一想到的是使用继承，但是这只是面向对象的一种复用方式－ 白盒复用。<br>子类继承父类，父类中的实现对子类可见，若是父类的实现代码改变，子类代码也就需要跟着改变。<br>另一种方式，对象组合－黑盒复用。对象组合要求对象之间定义好接口，相互之间使用接口引用。对象内部的实现是不可见的。</p>
<p>因为继承父类，父类的实现对子类完全可见甚至可改变，所以父类中的任何一个改变都有可能影响到子类，这样破坏了封装性，代码非常脆弱。<br>而使用组合的方式，对象之间使用接口的方式进行调用。接口的实现改变了，但并不影响接口外部的调用，这样的代码非常稳固，复用性高</p>
<p>使用原则：大多数情况下，组合方式优先于继承，使用这种方式的代码更容易维护。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/09/dapper-的学习/" itemprop="url">
                  dapper 的学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-09T12:32:45+08:00" content="2016-04-09">
              2016-04-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式服务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式服务</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="dapper-大规模分布式跟踪系统"><a href="#dapper-大规模分布式跟踪系统" class="headerlink" title="dapper 大规模分布式跟踪系统"></a>dapper 大规模分布式跟踪系统</h4><p>在分布式系统中，一次请求会跨越几个甚至几十个子系统所以我们很难统计出每个系统之间的耗时问题。<br>所以google研发出dapper ， twitter基于dapper研发出zipkin这些大规模耗时跟踪系统。</p>
<h4 id="dapper-如何跟踪系统之间的耗时"><a href="#dapper-如何跟踪系统之间的耗时" class="headerlink" title="dapper 如何跟踪系统之间的耗时"></a>dapper 如何跟踪系统之间的耗时</h4><p>下图是分布式系统中最普遍的一次请求，用户发起request请求，A服务接收到，使用rpc调用下面的子系统。<br>最终形成一颗调用树，所以在需要每次做rpc调用的时候进行时间统计。</p>
<p><img src="http://bigbully.github.io/Dapper-translation/images/img1.png" alt="dapper的trace"></p>
<h5 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h5><p>一次完整的跟踪叫做trace，从请求到服务器开始，服务器返回response结束，跟踪每次rpc调用的耗时。</p>
<h5 id="span"><a href="#span" class="headerlink" title="span"></a>span</h5><p>在调用rpc服务中，产生一个span用来记录rpc接受到请求的时间，rpc返回请求的时间。<br>span中下面几个参数</p>
<pre><code>trace_id             用于标示一次完整的请求id
span_id            当前这次调用span_id
parent_id            上层服务的调用span_id        最上层服务parent_id为null
annotations        用于标记的时间戳
</code></pre><p>span在rpc收到请求创建，在rpc返回响应被收集并且销毁。<br>在rpc调用时，调用方需要将自己的span信息封装到请求中，被调用方接受到请求，从请求中拿到调用方的trace_id，span_id，生成自己的span。</p>
<p>这样我们可以从收集的时间日志中找到所有的属于trace_id的所有span数据，根据span的parent_id和span_id就能找到自己的完整的调用链，再根据调用链中的annotaion计算出每个服务所消耗的时间</p>
<h5 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h5><p>时间注释，一个span中会有多个annotation注释描述。<br>在dapper的论文中没有详细描述所需的annotation，在zipkin中，对其的描述是这样。<br>一次rpc调用中会有四个核心的annotation</p>
<pre><code>server receive      服务器接收         sc
client send         客户端发送        cs
client receive      客户端接收        cr
server send         服务器发送        ss
</code></pre><p>这个四个核心的annotation记录下一次调用耗时</p>
<pre><code>      调用方rpc                    被调用方rpc

    -------&gt;
                              ---------&gt;

                              &lt;---------
    &lt;-------          

      sc                                


      cs                                sr


      cr                                ss


      ss    

调用方会产生这个四个时间戳，而被调用方因其没有调用其他rpc，所以只有sr和ss两个事件
span会在sc这个事件中被创建,并且存活于threadlocal中,在ss这个事件中被收集并且被销毁于threadlocal中        
</code></pre><h4 id="dapper-收集记录"><a href="#dapper-收集记录" class="headerlink" title="dapper 收集记录"></a>dapper 收集记录</h4><p>如下图，dapper纪录日志放入log file中，dapper collectors 定时请求拉取日志，存放到bigtable中。<br>尽管这样，日志量还是太大，dapper采用采样率的方式进行日志采集，采样率为1/1024。<br>zipkin 对收集工作做的更为复杂，实现了scribe方式，解决任何节点的故障的数据丢失问题。</p>
<p><img src="http://bigbully.github.io/Dapper-translation/images/img5.png" alt="dapper的trace"></p>
<h4 id="关于rpc的改造"><a href="#关于rpc的改造" class="headerlink" title="关于rpc的改造"></a>关于rpc的改造</h4><p>dapper没有开源，zipkin的对其dapper的设计进行实现。并且提供java的客户端brave<br>我们的线上服务使用的dubbo框架，所以只要将brave的api嵌入的dubbo中，并且在rpc调用中将当前的span信息加入到请求中。就可以完成对请求时间日志收集的工作，后端工作zipkin已经实现。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>paper传送门:</p>
<blockquote>
<p>原文地址:<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36356.pdf" target="_blank" rel="external">http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36356.pdf</a><br>译文地址:<a href="http://bigbully.github.io/Dapper-translation/" target="_blank" rel="external">http://bigbully.github.io/Dapper-translation/</a></p>
</blockquote>
<p>todo:    </p>
<blockquote>
<p>阅读dubbo源码<br>阅读brave的demo源码<br>改造dubbo</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/05/effective-java读书笔记-静态工厂/" itemprop="url">
                  effective java读书笔记-静态工厂
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-05T22:32:36+08:00" content="2016-04-05">
              2016-04-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="静态工厂方法-static-method-factory"><a href="#静态工厂方法-static-method-factory" class="headerlink" title="静态工厂方法 static method factory"></a>静态工厂方法 static method factory</h4><p>静态工厂是effective java 中的第一节，本文大部分内容是从上面摘抄的。<br>static method factory 译为静态工厂模式，指的是类可以提供一个静态工厂方法，一个返回类的实例的静态方法。</p>
<pre><code>public static final Boolean FALSE = new Boolean(false);
public static final Boolean TRUE = new Boolean(true);

public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}

public Boolean(boolean value) {
    this.value = value;
}
</code></pre><p>在java8 中前者为静态工厂创建对象，后者为构造方法创建对象。</p>
<p>那么静态工厂的优点</p>
<p>1.静态方法在方法命名上更具备可读性<br>    用构造方法创建对象的时候，传递不同的参数生成不同类型的对象。但是这并不明显，若不去查看api我们不能看出构造方法创建的到底是哪些对象。而且静态工厂可以在方法上作特征对象的命名。</p>
<p>2.静态方法参数的灵活性<br>    与上述的优点相同，使用构造方法创建不同类型对象时会出现这样一个问题。当我们需要相同类型的参数，创建不同类型的对象，这个问题导致构造方法极其难使用。如果使用静态方法我们完全可以在方法名上进行区别。</p>
<p>3.不必每次调用的时候都创建新的对象<br>    我们可以利用静态工厂对常用的单例的对象进行缓存。<br>    public static Boolean valueOf(boolean b) {<br>        return (b ? TRUE : FALSE);<br>    }<br>    每次调用valueOf()的时候并不会创建新的对象而是使用缓存中的Boolean对象，这样对类的实例有很好的控制权利，但是要保证类是线程安全的并且单例的。</p>
<p>4.静态工厂可以返回<strong>类的任何子类型</strong><br>    这优点实在是太好啦，api可以返回对象，却不需要将类的构造公有化（公有化子类就可以），以这种隐藏构造子类代码的方式可以使api对外部变的非常简洁，特别适用于服务提供者框架中进行解耦。</p>
<pre><code>private static final Map&lt;String,Provider&gt; providers = new ConcurrentHashMap&lt;String, Provider&gt;();
static{
    providers.put(&quot;xml&quot;,new XMLProvider());
    providers.put(&quot;json&quot;,new JSONProvider());
}

private ServiceFactory(){

}

public Service getService(String type){
    return providers.get(type).newService();
}    
</code></pre><p>在这个factory中，外界只需要给出需要的类型，完全不需要关注其service是如何创建的，创建何种类型，甚至可以做到外部只关注获得Service接口,外部面向接口进行编程。从而降低代码的耦合程度。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/02/python-无法安装setuptools问题/" itemprop="url">
                  python 无法安装setuptools问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-02T18:43:19+08:00" content="2016-04-02">
              2016-04-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Python无法安装setuptools解决"><a href="#Python无法安装setuptools解决" class="headerlink" title="Python无法安装setuptools解决"></a>Python无法安装setuptools解决</h2><p>centos6.5阿里云的新机器，更新python版本之后安装setuptools，但是一直报错。说不能解析https,也ping不同这个其中报错的https网址</p>
<p>查看之后发现是python内置的urllib模块不支持https协议，是因为安装python之前没有编译openssl 这样的ssl库,以至于python不支持ssl</p>
<pre><code>yum install openssl-devel
</code></pre><p>找到python的安装目录，重新编译python</p>
<pre><code>./configure
make
make install
</code></pre><p>测试</p>
<pre><code>import urllib
urllib.urlopen(&apos;https://www.baidu.com&apos;)
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/27/tcp详解学习笔记-tcp建立终止/" itemprop="url">
                  tcp详解学习笔记-tcp建立终止
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-27T08:56:08+08:00" content="2016-03-27">
              2016-03-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="tcp建立连接三次握手"><a href="#tcp建立连接三次握手" class="headerlink" title="tcp建立连接三次握手"></a>tcp建立连接三次握手</h4><p>初始化连接、数据传输、关闭连接</p>
<h4 id="tcp建立连接三次握手-1"><a href="#tcp建立连接三次握手-1" class="headerlink" title="tcp建立连接三次握手"></a>tcp建立连接三次握手</h4><p>一般是由一端打开一个套接字，然后监听另一方的连接，服务器被动打开，客户端主动打开链接</p>
<p>1.客户端发送一个syn来创建主动打开，指明客户端需要创建链接的端口和时间序列号报文包<br>2.服务端回复客户端初始的syn和ack，ack为客户端传说的syn包的时间序列号＋1<br>3.最后客户端再发一个ack包，服务端接收到链接进入已创建状态</p>
<h4 id="tcp关闭连接四次握手"><a href="#tcp关闭连接四次握手" class="headerlink" title="tcp关闭连接四次握手"></a>tcp关闭连接四次握手</h4><p>tcp连接全双工的<br>1.由任意一端发送fin请求关闭连接，另一方受到后执行被动关闭，然后返回一个fin的ack<br>2.再由被动关闭的一端发送fin请求，另一端收到返回给一个fin的ack<br>3.连接进入关闭状态</p>
<h4 id="tcp的半关闭"><a href="#tcp的半关闭" class="headerlink" title="tcp的半关闭"></a>tcp的半关闭</h4><p>也是因为tcp时全双工的，当一方请求关闭，接收到关闭的一方还能send数据，完成后进行关闭。</p>
<h4 id="tcp状态变迁图"><a href="#tcp状态变迁图" class="headerlink" title="tcp状态变迁图"></a>tcp状态变迁图</h4><p><img src="http://pic002.cnblogs.com/images/2011/305779/2011070321301391.png" alt="全组合形式"></p>
<h4 id="呼入请求队列（链接请求从内核到应用层的过程）"><a href="#呼入请求队列（链接请求从内核到应用层的过程）" class="headerlink" title="呼入请求队列（链接请求从内核到应用层的过程）"></a>呼入请求队列（链接请求从内核到应用层的过程）</h4><p>tcp如何处理呼入的链接请求？<br>1.正在等待连接请求的一端又一个固定的链接队列，队列中的链接已经被tcp接受，但还没有被应用层接收<br>2.应用层指明队列的长度，叫做积压值(0-5之间)<br>3.syn到达时，tcp使用一个算法，根据俄当前链接队列中的连接数来确定是否接受这个链接。积压值说明的是tcp监听的端点已被tcp接受而等待应用层接受的最大链接数<br>4.对于一个新的链接请求，改tcp监听的端点的链接队列中还有空间，tcp将对syn进行确认并完成链接的建立，但是应用层只有在三次握手中的第三个报文段收到后才会知道这个新链接<br>5.如果对于新的链接请求，链接队列中已经没有空间，tcp将不会理会收到的syn，也不会发任何报文段。如果饮用层不能及时接受已经被tcp接受的链接，这些链接可能占满整个队列，客户端的主动打开最终将超时</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/16/tcp链接端口的理解/" itemprop="url">
                  tcp链接端口的理解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-16T22:35:05+08:00" content="2016-03-16">
              2016-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="tcp端口"><a href="#tcp端口" class="headerlink" title="tcp端口"></a>tcp端口</h2><p>tcp中的端口，一直以为tcp的端口是个类似的实体的东西，类似于存储数据的数据包的队列那种，所以一个server的端口只能处理一个链接，当server开启listen端口后，服务器接受到链接请求，server会分配一个随机的没有用到的端口给tcp链接。但是这是错的！</p>
<p>tcp使用本地地址和远端地址组成的4元组（目的ip，目的端口，本地ip，本地端口）来处理多个链接请求。这个端口在tcp内核中紧紧是协议中的一部分，内核中仅仅通过目的端口无法确定是哪个进程接受到请求，所以需要server端的端口才能确定和客户端的链接。另外只有处于listen状态中的进程才能接受新的链接请求。当有新的请求到达并且被接受，内核会创建一个处于estableished状态的链接，而且端口号不变与listen的端口号一致。</p>
<p>看个🌰</p>
<p>我们起一个服务，我这里起了个hexo服务，使用4000端口号<br>使用命令，查看链接</p>
<pre><code>netstat -a -n -f inet
</code></pre><p>可以看到一个处于listen的4000端口，显示本地地址*.4000， 远端地址是＊.＊，这表明可以接受任意主机的请求</p>
<pre><code>tcp4       0      0  *.4000                 *.*                    LISTEN     
</code></pre><p>这时候我们telnet 4000这个端口，可以看到有两个新的请求，一个本地端口4000 远端端口60352，这是server上的链接，另一个本地60352，远端4000，这是telnet客户端的链接</p>
<pre><code>tcp4       0      0  *.4000                 *.*                    LISTEN     
tcp4       0      0  127.0.0.1.4000         127.0.0.1.60352        ESTABLISHED
tcp4       0      0  127.0.0.1.60352        127.0.0.1.4000         ESTABLISHED
</code></pre><p>关于tcp的更多知识，tcp详解 18章，unix网络编程，都有对tcp进行详细的描述。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/16/hexo-next-添加为文章添加分类/" itemprop="url">
                  hexo next 为文章添加分类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-16T08:12:43+08:00" content="2016-03-16">
              2016-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="hexo-next-添加分类页"><a href="#hexo-next-添加分类页" class="headerlink" title="hexo next 添加分类页"></a>hexo next 添加分类页</h4><ol>
<li><p>新建一个页面，命名为 categories 。命令如下：</p>
<pre><code>hexo new page categories
</code></pre></li>
<li><p>编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。</p>
<pre><code>title: 分类
date: 2014-12-22 12:39:04
type: &quot;categories&quot;
---
</code></pre><p>注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：</p>
<pre><code>title: 分类
date: 2014-12-22 12:39:04
type: &quot;categories&quot;
comments: false
---
</code></pre></li>
<li><p>在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: /categories 注释去掉，如下:</p>
<pre><code>menu:
  home: /
  categories: /categories
  archives: /archives
  tags: /tags
</code></pre></li>
<li><p>但是这样部署之后，在分类页面还是看不到任何分类的，同时官方的next教程中并没有写。。<br>其实为文章添加分类关联的教程已经在hexo教程给出了。。<br>下面仅仅做个简单的介绍，全面的教程参照<a href="https://hexo.io/zh-cn/docs/front-matter.html#分类和标签" target="_blank" rel="external">hexo官方教程(需备梯子)</a></p>
</li>
</ol>
<h4 id="添加文章分类关联"><a href="#添加文章分类关联" class="headerlink" title="添加文章分类关联"></a>添加文章分类关联</h4><ol>
<li><p>hexo中有Front-matter这个概念，是文件最上方以 — 分隔的区域，用于指定个别文件的变量。举个栗子，在hexo new post article时会生成article.md文件，文件生成好的文章属性。</p>
<pre><code>---
title: hexo next 为文章添加分类
date: 2016-03-16 08:12:43
tags:
---
</code></pre></li>
<li><p>在其中添加categories属性，再部署之后就可以在分类页看到分类了</p>
<pre><code>---
title: hexo next 为文章添加分类
date: 2016-03-16 08:12:43
tags:
categories: 前端
--- 
</code></pre></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/scala-学习－准备环境/" itemprop="url">
                  scala 学习－准备环境
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-12T23:37:54+08:00" content="2016-03-12">
              2016-03-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Mac-Linux-下安装scala"><a href="#Mac-Linux-下安装scala" class="headerlink" title="Mac Linux 下安装scala"></a>Mac Linux 下安装scala</h4><p>1.下载scala</p>
<pre><code>从这里下载最新版本scala ,http://www.scala-lang.org/download/
</code></pre><p>2.安装scala</p>
<p>移动安装包到 </p>
<pre><code>/usr/local/
</code></pre><p>修改环境变量，sudo su进入root权限    </p>
<pre><code>vim /etc/profile
</code></pre><p>在文件末尾添加</p>
<pre><code>export PATH=&quot;$PATH:/usr/local/scala-2.11.7/bin&quot;
</code></pre><p>3.运行</p>
<p>在终端输入scala -version ，显示</p>
<pre><code>Scala code runner version 2.11.7 -- Copyright 2002-2013, LAMP/EPFL
</code></pre><p>或者 输入scala ，显示</p>
<pre><code>Welcome to Scala version 2.11.7 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_60).
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt; 
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="whx4J8" />
          <p class="site-author-name" itemprop="name">whx4J8</p>
          <p class="site-description motion-element" itemprop="description">github.com/whx4J8</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">whx4J8</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
